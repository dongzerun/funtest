package main
// under go1.6
// panic: runtime error: index out of range

// goroutine 1 [running]:
// panic(0x489e20, 0xc82000a0b0)
//         /usr/local/go/src/runtime/panic.go:464 +0x3e6
// main.(*AdsOrder).Swap(0xc82000e140, 0xd, 0xffffffffffffffff)
//         <autogenerated>:3 +0x14b
// sort.doPivot(0x7f9e847a20d8, 0xc82000e140, 0x0, 0xe, 0xc82000e140, 0x18)
//         /usr/local/go/src/sort/sort.go:178 +0x59d
// sort.quickSort(0x7f9e847a20d8, 0xc82000e140, 0x0, 0xe, 0x7)
//         /usr/local/go/src/sort/sort.go:195 +0xa3
// sort.Sort(0x7f9e847a20d8, 0xc82000e140)
//         /usr/local/go/src/sort/sort.go:229 +0x74
// main.main()
//         /tmp/test.go:88 +0x39e
// exit status 2

import (
	"math/rand"
	"sort"
	"time"
)

func init() {
	rand.Seed(time.Now().UnixNano())
}

type Ad struct {
	Weight int
}

type AdsOrder []*Ad

func (a AdsOrder) Len() int {
	return len(a)
}

// 这么做排序可能不太好，但是暂时够用了
func (a AdsOrder) Less(i, j int) bool {
	if rand.Intn(2) == 0 {
		return true
	} else {
		return false
	}
	if a[i].Weight > a[j].Weight {
		return true
	}

	return false
}

func (a AdsOrder) Swap(i, j int) {
	a[i], a[j] = a[j], a[i]
}

func main() {
	ads := []*Ad{
		&Ad{
			Weight: 10,
		},
		&Ad{
			Weight: 19,
		},
		&Ad{
			Weight: 1,
		},
		&Ad{
			Weight: 101,
		},
		&Ad{
			Weight: 4,
		},
		&Ad{
			Weight: 190,
		},
		&Ad{
			Weight: 7,
		},
		&Ad{
			Weight: 11,
		},
		&Ad{
			Weight: 98,
		},

		&Ad{
			Weight: 1,
		},
		&Ad{
			Weight: 9,
		},
		&Ad{
			Weight: 22,
		},
		&Ad{
			Weight: 11,
		},
		&Ad{
			Weight: 12,
		},
	}

	sort.Sort(AdsOrder(ads))
}
